import bindings as bi

from gen_python import * #algo_to_classname


def gen_module(schema, name):
    classname = algo_to_classname(name)
    extra_imports = extra_imports_for(name)
    help_preamble = help_preamble_for(name)
    help_epilogue = help_epilogue_for(name)
    init_extra = init_extra_for(name)
    class_extra = class_extra_for(name)
    module_extra = module_extra_for(name)

    yield "#!/usr/bin/env python"
    yield "# -*- encoding: utf-8 -*-"
    yield "#"
    yield "# This file is auto-generated by h2o-3/h2o-bindings/bin/gen_python.py"
    yield "# Copyright 2016 H2O.ai;  Apache License Version 2.0 (see LICENSE for details)"
    yield "#"
    yield """
import collections

from google.protobuf import text_format

from tensorflow.core.framework import op_def_pb2
from tensorflow.python.framework import op_def_registry
from tensorflow.python.framework import ops
from tensorflow.python.framework import op_def_library
    """
    if extra_imports:
        yield reindent_block(extra_imports, 0) + ""

    args = []
    kwds = {}
    for param in schema["parameters"]:
        assert (param["type"][:4] == "enum") == bool(param["values"]), "Values are expected for enum types only"
        ptype = translate_type(param["type"], param["values"])
        name = param["name"]
        if name in reserved_words:
            name += "_"

        if not param["required"]:
            v = param["default_value"]
            if v == "AUTO":
                v = "\"AUTO\""
            kwds[name] = v
        else:
            args.append(name)
    if len(args) == 0:
        args.append("x")

    fmtargs = []
    fmtargs.extend(args)

    kwdargs = ["%s=%s" % (k, v) for k, v in kwds.iteritems()]
    fmtargs.extend(kwdargs)
    yield """
def %s(%s):\n""" % (classname, ", ".join(fmtargs))
    yield """
    \"\"\"
"""
    yield ""
    yield "    Parameters"
    yield "    ----------"
    param_names = []
    for param in schema["parameters"]:
        assert (param["type"][:4] == "enum") == bool(param["values"]), "Values are expected for enum types only"
        ptype = translate_type(param["type"], param["values"])
        name = param["name"]
        if name in reserved_words: name += "_"
        param_names.append(name)
        if param["required"]: ptype += ", required"
        yield "      %s : %s" % (name, bi.wrap(ptype, " " * (9 + len(name)), indent_first=False))
        yield bi. wrap(param["help"], " " * 8)
        if param["default_value"] is not None:
            yield "        Default: %s" % stringify(param["default_value"])
        yield ""
    yield "    \"\"\""

    xargs = list(args)

    if len(args) == 0 or args[0] == "x":
        xargs = ["x=x"]

    fmtargs = []
    fmtargs.extend(xargs)

    kwdargs = ["%s=%s" % (k, v) for k, v in kwds.iteritems()]

    fmtargs.extend(kwdargs)

    yield "    result = _op_def_lib.apply_op(\"%s\", %s)" % (classname,', '.join(fmtargs))
    yield "    return result"

    yield """
def _InitOpDefLibrary():
  op_list = op_def_pb2.OpList()
  text_format.Merge(_InitOpDefLibrary.op_list_ascii, op_list)
  op_def_registry.register_op_list(op_list)
  op_def_lib = op_def_library.OpDefLibrary()
  op_def_lib.add_op_list(op_list)
  return op_def_lib
    """

    yield """
_InitOpDefLibrary.op_list_ascii = \"\"\"op {
  name: "%(name)s"
  """ % dict(name=classname)

    for arg in args:
        yield """
  input_arg {
    name: "%(input_arg)s"
    type_attr: "T"
  }
  """ % dict(input_arg=arg)

    for arg, value in kwds.iteritems():
        kind = "type: DT_FLOAT"
        yield """
  input_arg {
    name: "%(input_arg)s"
    %(kind)s
  }
  """ % dict(input_arg=arg, kind=kind)

    outputs = ["output"]
    for arg in outputs:
        yield """
  output_arg {
    name: "output"
    type_attr: "T"
  }
    """ % dict(name=classname)

    yield """
  attr {
    name : "T"
    type : "type"
  }
    """

    for arg in args:
        yield """
    attr {
        name: "%(name)s"
        type: "%(ptype)s"
    }
    """ % dict(name=name, ptype="list(type)")

    for name, value in kwds.iteritems():
        yield """
    attr {
        name: "%(name)s"
        type: "%(ptype)s"
        has_minimum: true
        minimum: 1
    }
    """ % dict(name=name, ptype="list(type)")

    yield """
}
\"\"\"
_op_def_lib = _InitOpDefLibrary()
    """


def _start_shell(local_ns=None):
  # An interactive shell is useful for debugging/development.
  import IPython
  user_ns = {}
  if local_ns:
    user_ns.update(local_ns)
  user_ns.update(globals())
  IPython.start_ipython(argv=[], user_ns=user_ns)


def main():
    print("generating tensorflow bindings")

    bi.init("Python", "../../../h2o-py/h2o/deepwater/", clear_dir=False)

    # modules = [("deeplearning", "H2OAutoEncoderEstimator")]  # deeplearning module contains 2 classes in it...
    # for schema in bi.schemas():
    #     print schema

    # _start_shell()
    modules = []
    for name, mb in bi.model_builders().items():
        module = name
        if name == "drf": module = "random_forest"
        if name == "naivebayes": module = "naive_bayes"
        bi.vprint("Generating model: " + name)
        bi.write_to_file("%s.py" % module, gen_module(mb, name))
        modules.append((module, algo_to_classname(name)))

    bi.write_to_file("__init__.py", gen_init(modules))

if __name__ == "__main__":
    main()

